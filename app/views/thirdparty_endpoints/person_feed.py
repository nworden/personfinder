# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Code shared by third-party endpoint (API and feeds) view modules."""

import django.http
import xml.etree.ElementTree as ET

import config
import model
import pfif
import utils
import views.thirdparty_endpoints.base


ATOM = views.thirdparty_endpoints.base.ATOM
GPF = views.thirdparty_endpoints.base.GPF
GEORSS = views.thirdparty_endpoints.base.GEORSS

_DEFAULT_MAX_RESULTS = 10
_HARD_MAX_RESULTS = 200  # Clients can ask for more, but won't get more.


class PersonFeedView(views.thirdparty_endpoints.base.ThirdPartyFeedBaseView):
    """View for the person feed."""

    _TITLE = 'PFIF Person Feed generated by Person Finder'

    def setup(self, request, *args, **kwargs):
        """See docs on BaseView.setup."""
        # pylint: disable=attribute-defined-outside-init
        super(PersonFeedView, self).setup(request, *args, **kwargs)
        self.params.read_values(
            get_params={
                'max_results': utils.validate_int,
                'min_entry_date': utils.validate_datetime,
                'skip': utils.validate_int,
                'version': utils.validate_version,
            })

    def check_auth(self):
        if self.env.config.read_auth_key_required and not (
                self.auth and self.auth.read_permission):
            raise django.core.exceptions.PermissionDenied

    def add_feed_elements(self, root):
        if self.env.repo == 'global':
            return self.error(404, 'No repository specified.')
        pfif_version = (
            self.params.version or
            pfif.PFIF_VERSIONS[pfif.PFIF_DEFAULT_VERSION])

        ET.SubElement(root, 'id').text = self.build_absolute_uri()
        ET.SubElement(root, 'title').text = PersonFeedView._TITLE

        max_results = min(
            self.params.max_results or _DEFAULT_MAX_RESULTS, _HARD_MAX_RESULTS)
        skip = self.params.skip or 0
        persons = self._get_query().fetch(max_results, offset=skip)
        records = [pfif_version.person_to_dict(person, person.is_expired)
                   for person in persons]
        for record in records:
            self._add_person_entry(root, record)

    def _get_query(self):
        query = model.Person.all_in_repo(self.env.repo, filter_expired=False)
        if self.params.min_entry_date:  # Scan forward.
            query = query.order('entry_date')
            query = query.filter('entry_date >=', self.params.min_entry_date)
        else:  # Show recent entries, scanning backward.
            query = query.order('-entry_date')
        return query

    def _add_person_entry(self, root, record):
        entry_el = ET.SubElement(root, 'entry')
        ET.SubElement(entry_el, 'id').text = (
            'pfif:%s' % record['person_record_id'])
        ET.SubElement(entry_el, 'title').text = (
            record.get('full_name', '').split('\n')[0])

    def log(self):
        self.log_api_action(
            model.ApiActionLog.READ, len(records), self.num_notes)
